// -------------- globals

// Go to https://developer.spotify.com/ and lgoin, then there should be a code demo, copy/paste the token here.
const _token = 'BQAeJlTTMNsCuKVdZrjKjtPP_R2zNrsmEcGkdKVDoIt_Q1pCwDb99R6AjshXmzuT0lyX0hna3ieCGP1xpPu0YZOPSQCY3n1LyQaHRRR2W4ysoGedaAWz54f1uhsEyr0OD1oJoyPUpbmju2IRQFvgsgGN01iYMKwhMlluSRZPqhdKavRkAjIzFCa3RcNZmHNTTxu48tei3OfBllhIq2IFDg7Mx4spuhA5-na2nIITBJYlonLWOWbf1k0VualxbzGEag';


var _user_and_prefixes = {
  'marczoid': ['marcmix '],
  'joost_johnas': ['boys ', 'de boys gaan wat beleven', 'siem en marc gaan wat beleven'],
  'lilapause': ['de krochten'],
  'reneesteinmann': ['beste discover weekly', 'siems toppertjes'],
}

// This should point to a web address with a JSON containing all playlists
// generated by get_playlists.html.
_playlists_path = 'https://raw.githubusercontent.com/marcvanzee/spotify-playlist-analysis/main/playlists.json'

_playlists = {}

_playlists_by_track = {}

// -------------- functions

function setHtml(fieldId, text) {
  document.getElementById(fieldId).innerHTML = text
}

function getTrackKey(track) {
  return track.artist + ' - ' + track.name;
}

function initGetPlaylists() {
  html = 'Using the following usernames and playlist prefixes:<br>';
  html += '<ul>';
  for (const [user, prefixes] of Object.entries(_user_and_prefixes)) {
    html += `<li><b>${user}</b>: "` + prefixes.join('", "') + '"</li>';
  }
  html += '</ul>'
  setHtml('settings', html)
}

function initAnalyzePlaylist() {

  function addOption(select_field, text, id) {
    const option = document.createElement('option');
    option.text = text;
    option.id = id
    select_field.add(option, select_field[-1]);
  }

  function addTracksToIndex(playlist) {
    for (const track of playlist.tracks) {
      key = getTrackKey(track);
      if (key in _playlists_by_track) {
        _playlists_by_track[key].push(playlist.id);
      } else {
        _playlists_by_track[key] = [playlist.id];
      }
    }
  }

  fetch(_playlists_path)
    .then((response) => response.json())
    .then((json) => {
      html = `Successfully retrieved ${Object.keys(json).length} playlists from
              <a href="${_playlists_path}">${_playlists_path}</a>, which is
              generated using <a href="get_playlists.html">get_playlists.html</a>`
      setHtml('status', html)
      document.getElementById('analyze-content').style.display = 'inline';
      const select = document.getElementById('playlist-selector');
      Object.values(json).map((playlist) => {
        const name = `${playlist.name} by ${playlist.user}`
        addOption(select, name, playlist.id);
        addTracksToIndex(playlist);
      });
      _playlists = json;
    })
}

async function fetchWebApi(endpoint, method, body) {
  const res = await fetch(`https://api.spotify.com/${endpoint}`, {
    headers: {
      Authorization: `Bearer ${_token}`,
    },
    method,
    body:JSON.stringify(body)
  });
  return await res.json();
}

async function getIterative(url, filter_fn = (x) => x) {
  let result = []
  let offset = 0
  while (true) {
    const new_result = (await fetchWebApi(
      `${url}?limit=50&offset=${offset}`, 'GET'
    )).items.filter(filter_fn);
    if (new_result && new_result.length) {
      result = result.concat(new_result);
      offset += 50;
    } else {
      break;
    }
  }
  return result;
}

async function getPlaylistTracks(playlist_id) {
  tracks = await getIterative(
      `v1/playlists/${playlist_id}/tracks`)
  tracks = tracks.map(({track}) => ({
    'artist': track.artists.map((artist) => artist.name).join('_'),
    'name': track.name,
  }))
  return tracks
}

async function getPlaylists(user) {
  function keep_playlist_fn(playlist) {
    prefixes = _user_and_prefixes[user];
    return prefixes.some(prefix => playlist.name.toLowerCase().startsWith(prefix))
  }

  async function process_playlist(playlist) {
    tracks = await getPlaylistTracks(playlist.id);
    return {
      'id': playlist.id,
      'name': playlist.name,
      'url': playlist.external_urls['spotify'],
      'user': user,
      'tracks': tracks,
    }
  }
  playlists = await Promise.all((await getIterative(
      `v1/users/${user}/playlists`,
      keep_playlist_fn)).map(process_playlist))

  return playlists;
}

function writePlaylists(playlists) {
  // Write as dictionary keyed by playlist id.
  playlists = Object.fromEntries(playlists.map(p => [p.id, p]));

  var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(playlists, null, '  '));
  var dlAnchorElem = document.getElementById('download');
  dlAnchorElem.setAttribute("href", dataStr);
  dlAnchorElem.setAttribute("download", "playlists.json");
  dlAnchorElem.style.display = "inline";
}

async function getAllPlaylists() {
  setHtml('status', '<i>Retrieving playlists...</i>');

  all_playlists = []
  for (const user in _user_and_prefixes) {
    setHtml('status', `<i>Getting playlists for ${user}...</i>`);
    playlists = await getPlaylists(user);
    all_playlists = all_playlists.concat(playlists);
  }
  setHtml('status', `<i>Done, found ${all_playlists.length} playlists!</i>`);

  writePlaylists(all_playlists);
}

async function analyzePlaylist() {
  const options = document.getElementById('playlist-selector').options;
  const playlist = _playlists[options[options.selectedIndex].id];

  let other_playlists = Object.keys(_playlists).filter(id => id != playlist.id);

  html = `<h2>Analysis of ${playlist.name} by ${playlist.user}</h2>`;

  let num_tracks = playlist.tracks.length;
  if (num_tracks != 30) {
    num_tracks += ' (BAD!! SHOULD BE 30)'
  } else {
    num_tracks += ' (GOOD!!)'
  }
  html += '<p><b>total tracks: </b>' + num_tracks + '</p>'

  artists_count = {};
  duplicates = {};
  for (const track of playlist.tracks) {
    trackKey = getTrackKey(track);
    playlistsWithTrack = _playlists_by_track[trackKey]
        .filter(id => other_playlists.includes(id))
        .map(id => _playlists[id])
    
    if (playlistsWithTrack.length > 0) {
      duplicates[trackKey] = playlistsWithTrack;
    }

    if (track.artist in artists_count) {
      artists_count[track.artist]++;
    } else {
      artists_count[track.artist] = 1;
    }
  }

  artists_count = Object.fromEntries(Object.entries(artists_count).filter(([k,v]) => v>1));

  num_double_artists = Object.keys(artists_count).length;
  if (num_double_artists == 0) {
    html += `<p><b>NO</b> artists occur more than once (GOOD!!!)`;
  } else {
    html += `<b>${num_double_artists}</b> artists occur more than once (BAD!!!):`;
    html += '<ul>';
    for (const [artist, count] of Object.entries(artists_count)) {
      html += `<li>${artist}: ${count} times</li>`;
    }
    html += '</ul>';
  }


  num_duplicates = Object.keys(duplicates).length;
  if (num_duplicates == 0) {
    html += '<p><b>ALL</b> tracks in this playlist are unique (VERY GOOD!!!!)';
  } else {
    html += `<p><b>${num_duplicates}</b> tracks also occur in previous playlists:`;
    html += '<ul>'
    for (const [trackKey, playlists] of Object.entries(duplicates)) {
      playlists_html = playlists.map(p => `${p.name} by ${p.user}`).join('</li><li>')
      playlists_html = '<ul><li>' + playlists_html + '</li></ul>'
      html += `<li><i>${trackKey}</i>, also occurs in:` + playlists_html + '</li>'
    }
    html += '</ul>'
  }

  setHtml('analysis', html);
}